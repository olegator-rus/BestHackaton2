/*
 * NETCAP - Traffic Analysis Framework
 * Copyright (c) 2017-2020 Philipp Mieden <dreadl0ck [at] protonmail [dot] ch>
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package decoder

import (
	"strings"
	"sync"

	"github.com/blevesearch/bleve"
	"github.com/blevesearch/bleve/document"
	"github.com/dreadl0ck/gopacket"
	"github.com/gogo/protobuf/proto"

	"github.com/dreadl0ck/netcap/types"
	"github.com/dreadl0ck/netcap/utils"
)

const (
	thresholdNVD = 1.5
	vulnDBPath   = "nvd-v2.bleve"
)

// NVDVulnerabilityItems represents the structure of an NVD vulnerability json file.
type NVDVulnerabilityItems struct {
	CVEDataType         string `json:"CVE_data_type"`
	CVEDataFormat       string `json:"CVE_data_format"`
	CVEDataVersion      string `json:"CVE_data_version"`
	CVEDataNumberOfCVEs string `json:"CVE_data_numberOfCVEs"`
	CVEDataTimestamp    string `json:"CVE_data_timestamp"`
	CVEItems            []struct {
		Cve struct {
			DataType    string `json:"data_type"`
			DataFormat  string `json:"data_format"`
			DataVersion string `json:"data_version"`
			CVEDataMeta struct {
				ID       string `json:"ID"`
				ASSIGNER string `json:"ASSIGNER"`
			} `json:"CVE_data_meta"`
			Problemtype struct {
				ProblemtypeData []struct {
					Description []struct {
						Lang  string `json:"lang"`
						Value string `json:"value"`
					} `json:"description"`
				} `json:"problemtype_data"`
			} `json:"problemtype"`
			References struct {
				ReferenceData []struct {
					URL       string   `json:"url"`
					Name      string   `json:"name"`
					Refsource string   `json:"refsource"`
					Tags      []string `json:"tags"`
				} `json:"reference_data"`
			} `json:"references"`
			Description struct {
				DescriptionData []struct {
					Lang  string `json:"lang"`
					Value string `json:"value"`
				} `json:"description_data"`
			} `json:"description"`
		} `json:"cve"`
		Configurations struct {
			CVEDataVersion string `json:"CVE_data_version"`
			Nodes          []struct {
				Operator string `json:"operator"`
				CpeMatch []struct {
					Vulnerable            bool   `json:"vulnerable"`
					Cpe23URI              string `json:"cpe23Uri"`
					VersionEndExcluding   string `json:"versionEndExcluding"`
					VersionStartIncluding string `json:"versionStartIncluding,omitempty"`
				} `json:"cpe_match"`
			} `json:"nodes"`
		} `json:"configurations"`
		Impact struct {
			BaseMetricV3 struct {
				CvssV3 struct {
					Version               string  `json:"version"`
					VectorString          string  `json:"vectorString"`
					AttackVector          string  `json:"attackVector"`
					AttackComplexity      string  `json:"attackComplexity"`
					PrivilegesRequired    string  `json:"privilegesRequired"`
					UserInteraction       string  `json:"userInteraction"`
					Scope                 string  `json:"scope"`
					ConfidentialityImpact string  `json:"confidentialityImpact"`
					IntegrityImpact       string  `json:"integrityImpact"`
					AvailabilityImpact    string  `json:"availabilityImpact"`
					BaseScore             float64 `json:"baseScore"`
					BaseSeverity          string  `json:"baseSeverity"`
				} `json:"cvssV3"`
				ExploitabilityScore float64 `json:"exploitabilityScore"`
				ImpactScore         float64 `json:"impactScore"`
			} `json:"baseMetricV3"`
			BaseMetricV2 struct {
				CvssV2 struct {
					Version               string  `json:"version"`
					VectorString          string  `json:"vectorString"`
					AccessVector          string  `json:"accessVector"`
					AccessComplexity      string  `json:"accessComplexity"`
					Authentication        string  `json:"authentication"`
					ConfidentialityImpact string  `json:"confidentialityImpact"`
					IntegrityImpact       string  `json:"integrityImpact"`
					AvailabilityImpact    string  `json:"availabilityImpact"`
					BaseScore             float64 `json:"baseScore"`
				} `json:"cvssV2"`
				Severity                string  `json:"severity"`
				ExploitabilityScore     float64 `json:"exploitabilityScore"`
				ImpactScore             float64 `json:"impactScore"`
				AcInsufInfo             bool    `json:"acInsufInfo"`
				ObtainAllPrivilege      bool    `json:"obtainAllPrivilege"`
				ObtainUserPrivilege     bool    `json:"obtainUserPrivilege"`
				ObtainOtherPrivilege    bool    `json:"obtainOtherPrivilege"`
				UserInteractionRequired bool    `json:"userInteractionRequired"`
			} `json:"baseMetricV2"`
		} `json:"impact"`
		PublishedDate    string `json:"publishedDate"`
		LastModifiedDate string `json:"lastModifiedDate"`
	} `json:"CVE_Items"`
}

func buildNVDQuery(vendor, software, version string) string {
	var b strings.Builder

	if len(vendor) > 0 {
		b.WriteString("+Description:\"")
		b.WriteString(vendor)
		b.WriteString("\"")
	}
	if len(software) > 0 {
		if len(vendor) > 0 {
			// add spacing if vendor is present
			b.WriteString(" ")
		}
		b.WriteString("+Description:\"")
		b.WriteString(software)
		b.WriteString("\"")
	}
	if len(version) > 0 {
		if len(software) > 0 || len(vendor) > 0 {
			// add spacing
			b.WriteString(" ")
		}
		b.WriteString("+Versions:")
		b.WriteString(version)
	}

	return b.String()
}

// searches for known vulnerabilities in the indexed bleve database
// TODO:
// - Make the threshold configurable on the commandline
// - add caching layer to avoid repeating matching operations.
func vulnerabilitiesLookup(software *types.Software) {
	if software == nil {
		return
	}
	if software.Version == "" {
		return
	}

	var (
		queryTerm          = buildNVDQuery(software.Vendor, software.Product, software.Version)
		query              = bleve.NewQueryStringQuery(queryTerm)
		search             = bleve.NewSearchRequest(query)
		searchResults, err = vulnerabilitiesIndex.Search(search)
	)
	if err != nil {
		utils.DebugLog.Println("failed to search for vulnerable software:", err)

		return
	}
	utils.DebugLog.Println("query vuln database:", queryTerm)
	for _, v := range searchResults.Hits {
		if v.Score > thresholdNVD {
			doc, _ := vulnerabilitiesIndex.Document(v.ID)
			writeVuln(software, doc)
		}
	}
}

type vulnerabilityStore struct {
	items map[string]struct{}
	sync.Mutex
}

var vulnStore = vulnerabilityStore{
	items: make(map[string]struct{}),
}

func writeVuln(software *types.Software, doc *document.Document) {
	// use CVE as map index to deduplicate
	id := string(doc.Fields[0].Value())

	vulnStore.Lock()
	if _, ok := vulnStore.items[id]; ok {
		vulnStore.Unlock()
		// exists, exit.
		return
	}
	vulnStore.items[id] = struct{}{}
	vulnStore.Unlock()

	var score, vector string
	if len(doc.Fields) > 3 {
		score = string(doc.Fields[3].Value())
		vector = string(doc.Fields[4].Value())
	}

	if vulnerabilityDecoder.writer != nil { // during unit tests, the vulnerability encoder might not be initialized
		vulnerabilityDecoder.write(&types.Vulnerability{
			Timestamp:    software.Timestamp,
			ID:           id,
			Description:  strings.Trim(string(doc.Fields[1].Value()), "\""),
			Severity:     string(doc.Fields[2].Value()),
			V2Score:      score,
			AccessVector: vector,
			Software:     software,
		})
	}
}

var vulnerabilityDecoder = newCustomDecoder(
	types.Type_NC_Vulnerability,
	"Vulnerability",
	"A vulnerability associated with a software product observed on the network",
	nil,
	func(layer gopacket.Packet) proto.Message {
		return nil
	},
	nil,
)
