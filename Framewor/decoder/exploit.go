/*
 * NETCAP - Traffic Analysis Framework
 * Copyright (c) 2017-2020 Philipp Mieden <dreadl0ck [at] protonmail [dot] ch>
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package decoder

import (
	"path/filepath"
	"strings"
	"sync"

	"github.com/blevesearch/bleve"
	"github.com/blevesearch/bleve/document"
	"github.com/dreadl0ck/gopacket"
	"github.com/gogo/protobuf/proto"

	"github.com/dreadl0ck/netcap/resolvers"
	"github.com/dreadl0ck/netcap/types"
	"github.com/dreadl0ck/netcap/utils"
)

const thresholdExploits = 2

type exploitStore struct {
	items map[string]struct{}
	sync.Mutex
}

var expStore = exploitStore{
	items: make(map[string]struct{}),
}

// searches for known exploits in the indexed bleve database
// TODO:
// - Make the threshold configurable on the commandline
// - add caching layer to avoid repeating matching operations.
func exploitsLookup(software *types.Software) {
	if software == nil {
		return
	}
	if software.Version == "" {
		return
	}

	var (
		queryTerm          = buildExploitQuery(software.Vendor, software.Product, software.Version)
		query              = bleve.NewQueryStringQuery(queryTerm)
		search             = bleve.NewSearchRequest(query)
		searchResults, err = exploitsIndex.Search(search)
	)
	utils.DebugLog.Println("query exploit database:", queryTerm)
	if err != nil {
		utils.DebugLog.Println("failed to search for vulnerable software:", err)

		return
	}
	// fmt.Println("search for ", software.Product, software.Vendor, software.Version)
	for _, v := range searchResults.Hits {
		if v.Score > thresholdExploits {
			doc, _ := exploitsIndex.Document(v.ID)
			writeExploit(software, doc)
		}
	}
}

func buildExploitQuery(vendor, software, version string) string {
	var b strings.Builder

	if len(vendor) > 0 {
		b.WriteString("+Description:\"")
		b.WriteString(vendor)
		b.WriteString("\"")
		b.WriteString(" ")
	}
	if len(software) > 0 {
		b.WriteString("+Description:\"")
		b.WriteString(software)
		b.WriteString("\"")
		b.WriteString(" ")
	}
	if len(version) > 0 {
		b.WriteString("+Description:\"")
		b.WriteString(version)
		b.WriteString("\"")
		b.WriteString(" ")
	}

	return b.String()
}

func writeExploit(software *types.Software, doc *document.Document) {
	// use exploitDB numeric ID as index
	id := string(doc.Fields[0].Value())

	expStore.Lock()
	if _, ok := expStore.items[id]; ok {
		expStore.Unlock()
		// exists, exit.
		return
	} else {
		expStore.items[id] = struct{}{}
	}
	expStore.Unlock()

	// spew.Dump("exploit", doc.Fields)

	exploitDecoder.write(&types.Exploit{
		Timestamp:   software.Timestamp,
		ID:          id,
		Description: strings.Trim(string(doc.Fields[2].Value()), "\""),
		File:        string(doc.Fields[1].Value()),
		Date:        string(doc.Fields[3].Value()),
		Author:      string(doc.Fields[4].Value()),
		Typ:         string(doc.Fields[5].Value()),
		Platform:    string(doc.Fields[6].Value()),
		Port:        string(doc.Fields[7].Value()),
		Software:    software,
	})
}

var exploitDecoder = newCustomDecoder(
	types.Type_NC_Exploit,
	"Exploit",
	"An exploit proof of concept code snippet for a vulnerable application",
	func(e *customDecoder) error {
		// Load vulnerabilities DB index
		var (
			err       error
			indexName = filepath.Join(resolvers.DataBaseSource, "exploit-db.bleve")
		)
		exploitsIndex, err = utils.OpenBleve(indexName)
		if err != nil {
			return err
		}

		return nil
	},
	func(layer gopacket.Packet) proto.Message {
		return nil
	},
	func(decoder *customDecoder) error {
		utils.CloseBleve(exploitsIndex)

		return nil
	},
)
